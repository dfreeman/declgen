'use strict';

const generate = require('@babel/generator').default;
const t = require('@babel/types');
const BroccoliPlugin = require('broccoli-plugin');
const fs = require('fs-extra');
const path = require('path');

module.exports = {
  name: require('./package').name,

  setupDeclarationGeneratorRegistry(type, registry) {
    if (type === 'parent') {
      let added = false;
      let { project } = this;

      registry.addGenerator({
        name: 'config-types',
        extensions: ['js'],
        toTree() {
          if (!added) {
            added = true;

            let outputPath = `${project.name()}/config/environment.d.ts`;
            let config = [project.config('development'), project.config('test'), project.config('production')];
            return new ConfigTypeGeneratorPlugin(outputPath, config);
          }
        }
      });
    }
  }
}

class ConfigTypeGeneratorPlugin extends BroccoliPlugin {
  constructor(destination, config) {
    super([], { persistentOutput: true });
    this.hasBuilt = false;
    this.destination = destination;
    this.config = config;
  }

  build() {
    if (this.hasBuilt) return;

    this.hasBuilt = true;

    let fullDestination = `${this.outputPath}/${this.destination}`;
    let declaration = t.program([
      Object.assign(
        t.variableDeclaration('const', [
          t.variableDeclarator(
            Object.assign(t.identifier('config'), {
              typeAnnotation: t.tsTypeAnnotation(t.tsUnionType(this.config.map(item => typeFor([], item))))
            })
          )
        ]),
        { declare: true }
      ),
      t.exportDefaultDeclaration(t.identifier('config'))
    ]);

    let code = `// This is an autogenerated file. Do not edit it directly.\n${generate(declaration).code}`;

    fs.ensureDirSync(path.dirname(fullDestination));
    fs.writeFileSync(fullDestination, code);
  }
}

function typeFor(path, value) {
  if (typeof value === 'object' && !!value) {
    return t.tsTypeLiteral(
      Object.keys(value).map(key => {
        let propertyValue = value[key];
        let propertyValueType =
          path.length === 0 && key === 'environment'
            ? t.tsLiteralType(t.stringLiteral(propertyValue))
            : typeFor(path.concat(key), propertyValue);

        return t.tsPropertySignature(t.identifier(key), t.tsTypeAnnotation(propertyValueType));
      })
    );
  } else if (Array.isArray(value)) {
    return t.tsTupleType(value.map((item, index) => typeFor(path.concat(index), item)));
  } else if (typeof value === 'string') {
    return t.tsStringKeyword();
  } else if (typeof value === 'number') {
    return t.tsNumberKeyword();
  } else if (typeof value === 'boolean') {
    return t.tsBooleanKeyword();
  } else if (value === null || value === undefined) {
    return t.tsNullKeyword();
  } else {
    return t.tsUnknownKeyword();
  }
}
